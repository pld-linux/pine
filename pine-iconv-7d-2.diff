--- pine4.56/doc/iconv.txt
+++ iconv-7d-2/doc/iconv.txt
@@ -0,0 +1,66 @@
+ChangeLog of the iconv support:
+
+7d - Release date: Jun  7 2003
+------------------------------
+
+Updates from Jungshik Shin:
+
+ fix bounce command to not attempt to convert mail by temporarily
+ reseting SEND_CHAR_SET before calling the send function to keep
+ it from converting to send_charset
+
+ fix the last char of the subject which was chopped off in the mail
+ index screen.
+
+ fix list management editorial fix to apply assumed-charset to all
+ headers by changing format_editorial() to reset VAR_ASSUMED_CHAR_SET
+ before calling rfc1522_decode()
+
+ overlong rfc2047 encoded words are now decoded
+
+ send-charset help updated
+
+Updates from Bernhard Kaindl:
+
+ Remove strncpy_pad() - It's not used right now.
+
+ minor tweaks and documentation improvements for conv_strncpy()
+ (ensure that the output string is always terminated)
+
+ Reduce the lines of code in rfc1522_decode which are neccesary to
+ copy(and convert, if neccesary) strings which looked like encoded
+ words and remaining string parts.
+
+7c - Release date: Jun  1 2003
+------------------------------
+
+Updates from Bernhard Kaindl:
+
+ Update to pine 4.56 which improved the charset conversion warning
+ and made it possible to merge gf_convert_iconv_opt() into convert_chartset()
+ which also allowed to omit the #ifdefs to call gf_convert_iconv_opt() if
+ iconv() is available.
+
+ Also fixed the bug which the messed up the mailinglist management editoral
+
+ The baseline of all changes done is that the unified diff
+ of 7c is 4k smaller then 7a.
+
+7a - Release date: May 28 2003
+------------------------------
+
+Updates from Junkshik Shin:
+
+ Added 'send-charset' option and made necessary changes.
+ conv_sstrncpy() also has a new parameter because it's used for both
+ directions now.
+
+ 'send-charset' option is global and I have yet to make some more changes
+ to let users change the charset of outgoing emails at the time of
+ composition.
+
+Currently Known Bugs:
+---------------------
+
+- If pass-control-characters-as-is is not enabled, many Unicode characters
+  are not displayed correctly, filter functions need to be aware of UTF-8.
--- pine4.56/pine/filter.c
+++ iconv-7d-2/pine/filter.c
@@ -65,6 +65,9 @@
 
 
 #include "headers.h"
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
 
 
 /*
@@ -704,6 +707,12 @@
 			register unsigned char *GF_EOB_INIT(FI); \
 			register unsigned char *GF_IP_INIT(FO);  \
 			register unsigned char *GF_EIB_INIT(FO);
+#ifdef HAVE_ICONV
+#define	GF_ICINIT(I, O)	unsigned char *GF_OP_INIT(I);  \
+			unsigned char *GF_EOB_INIT(I); \
+			unsigned char *GF_IP_INIT(O);  \
+			unsigned char *GF_EIB_INIT(O);
+#endif
 
 #define	GF_CH_RESET(F)	(op = eob = GF_QUE_START(F), \
 					    (F)->queueout = (F)->queuein = 0)
@@ -2164,6 +2173,123 @@
     }
 }
 
+#ifdef HAVE_ICONV
+/*
+ * This filter converts the input buffer in the MIME charset of 
+ * a message, for example) to another (the user's display charset)
+ * using iconv(3), POSIX/Single Unix Standard API. 
+ */
+void
+gf_convert_charset(f, flg)
+    FILTER_S *f;
+    int       flg;
+{
+    static iconv_t iconv_desc;
+    static int einval_inbytesleft;
+    GF_ICINIT(f, f->next);
+
+    switch (flg) {
+    case GF_DATA: {
+	int conv, inbytesleft = eob - op, outbytesleft = eib - ip;
+	/* If einval_inbytesleft is set our iconv() encountered an incomplete
+	 * multibyte sequence and we asked for more input. In case the number
+	 * of chars left to convert did not change, we should be at the end
+	 * of input and then we would have an incomplete multibyte sequence
+	 * at the end of input. The only thing we could do is to tell the
+	 * user and abort to prevent endlessly trying to convert the incomplete
+	 * input.
+	 */
+	if (inbytesleft == einval_inbytesleft) {
+		char *einval_error = "[invalid multibyte seq at end of input]";
+		dprint(2,(debugfile, "inval multibyte seq at end of input\n"));
+		for (;*einval_error;einval_error++)
+		    GF_PUTC(f->next, *einval_error);
+		GF_FLUSH(f->next);
+		/* We need to throw the remaing invalid sequence away: */
+		op = eob;
+		GF_CH_RESET(f);
+		break;
+	}
+	while (1) {
+	    if (!outbytesleft || !inbytesleft) {
+		dprint(2,(debugfile, "gf_convert_iconv:flushing output:%d, %d\n",
+			  inbytesleft, outbytesleft));
+		GF_FLUSH(f->next);
+		outbytesleft = eib - ip;
+	    }
+	    if (!inbytesleft) {
+		dprint(2,(debugfile, "gf_convert_iconv:need input, outleft=%d\n",
+			  outbytesleft));
+		GF_CH_RESET(f);
+		break;
+	    }
+	    einval_inbytesleft = -1;
+	    conv = iconv(iconv_desc, (char **)&op, &inbytesleft,
+				      (char **)&ip, &outbytesleft);
+	    if (conv != (size_t) (-1)) { /* iconv succeeded */
+		dprint(2,(debugfile, "irres. conv. count: %d, il: %d, ol: %d\n",
+			  conv, inbytesleft, outbytesleft));
+	    /* iconv failed. check errno */
+	    } else if (errno == E2BIG){
+		dprint(2,(debugfile, "e2big: outbytesleft=%d\n", outbytesleft));
+		outbytesleft = 0;
+	    } else if (errno == EILSEQ){
+		char hexout[3];
+		dprint(2,(debugfile, "eilseq: ill.octet=0x%02x, il=%d, ol=%d\n",
+			  *op, inbytesleft, outbytesleft));
+		sprintf(hexout, "%2x", *op++);
+		inbytesleft--;
+		GF_PUTC(f->next, '[');
+		GF_PUTC(f->next, hexout[0]);
+		GF_PUTC(f->next, hexout[1]);
+		GF_PUTC(f->next, ']');
+		outbytesleft = eib - ip;
+		iconv(iconv_desc, NULL, NULL, NULL, NULL);
+	    } else if (errno == EINVAL){
+		/* 
+		 * We have to return from this function now because our input
+		 * buffer contains an incomplete multibyte character which we
+		 * can't complete without the next bytes of input which the
+		 * filter below us will send us when it as more input for us.
+		 * Next time around we need the incomplete bytes in the input
+		 * buffer and will complete them to a multibyte character.
+		 */
+		dprint(2,(debugfile,
+			  "einval: %d, ol: %d, incomplete input: 0x%02x\n",
+			  inbytesleft, outbytesleft, (unsigned char) *op));
+		/*
+		 * Before we abort here, we need to flush already converted
+		 * output up the filter chain, otherwise we may loose this
+		 * already converted content. Note:
+		 * Don't use GF_CH_RESET(f) in this path, we have at least
+		 * one byte in our input buffer which we need next time to
+		 * complete the sequence to a valid multibyte character!
+                 */
+		GF_FLUSH(f->next);
+		/*
+		 * In case we are at the end of all input, and we have
+		 * an incomplete multibyte sequence left, we must find
+		 * a way to not fall into a loop, remember the bytes left:
+		 */
+		einval_inbytesleft = inbytesleft;
+		/* Take the straigt way out now(see the comments above) */
+		break;
+	    } /* errno check */
+	} /*  while (1) */
+	GF_END(f, f->next);
+	break;
+    } /* GF_DATA */
+    case GF_RESET:
+	iconv_desc = (iconv_t)(f->opt);
+	iconv(iconv_desc, NULL, NULL, NULL, NULL);
+    	einval_inbytesleft = -1;
+	break;
+    case GF_EOD:
+	GF_FLUSH(f->next);
+	(*f->next->f)(f->next, GF_EOD);
+    } /* switch (flg) */
+}
+#else
 
 /*
  * This filter converts characters in one character set (the character
@@ -2197,6 +2323,7 @@
 
     }
 }
+#endif
 
 
 /*
@@ -2204,7 +2331,7 @@
  */
 void *
 gf_convert_charset_opt(conv_table)
-    unsigned char *conv_table;
+    conversion_t conv_table;
 {
     return((void *) conv_table);
 }
@@ -6436,9 +6563,10 @@
 
 	while(GF_GETC(f, c)){
 
-	    if(iscntrl(c & 0x7f)
+	    if(iscntrl(!f->opt ? c & 0x7f : c)
 	       && !(isspace((unsigned char) c)
 		    || c == '\016' || c == '\017' || c == '\033')){
+		dprint(1, (debugfile, "-- gf_control filter: %x\n",c));
 		GF_PUTC(f->next, '^');
 		GF_PUTC(f->next, c + '@');
 	    }
--- pine4.56/pine/init.c
+++ iconv-7d-2/pine/init.c
@@ -214,6 +214,18 @@
 
 CONF_TXT_T cf_text_character_set[] =	"Reflects capabilities of the display you have. Default: US-ASCII.\n# Typical alternatives include ISO-8859-x, (x is a number between 1 and 9).";
 
+#ifdef HAVE_ICONV
+CONF_TXT_T cf_text_send_charset[] =	"Specifies the MIME charset that a message will be sent in. If not set,\n# the value of character set will be used.";
+#endif
+
+CONF_TXT_T cf_text_assumed_charset[] =	"When MIME charset information is missing in Content-Type header field.\n# Message is assumed to be in this charset. Default: US-ASCII. Typical values\n# include ISO-8859-x, ISO-2022-JP, EUC-KR, GB2312, and Big5. The value of\n# header fields which are not encoded per RFC 2047\n# is also assumed to be\n# in this charset."; 
+
+CONF_TXT_T cf_text_charset_aliases[] =	"List of charset aliases. Each alias is a pair of charsets delimetered by a\n# single colon, the first one being an alias to the second one. The latter is\n# usually standard/prefered MIME name while the former is non-standard name used\n# by some email clients. For instance, you may have 'x-big5:big5,x-x-big5:big5,euc-cn:gb2312'";
+
+#ifdef HAVE_ICONV
+CONF_TXT_T cf_text_iconv_aliases[] =	"List of charset aliases to use with iconv(). Each alias is a pair of\n# charsets delimetered by a single colon, the first one being an alias to the\n# second one. The former is usually standard/prefered MIME name while the\n# latter is non-standard name used by iconv(3) on your system.\n#For example,\n# your iconv may use non-standard 'UTF8' for the standard 'UTF-8'. In that\n # case, you can put 'UTF-8:UTF8' here.";
+#endif
+
 CONF_TXT_T cf_text_editor[] =		"Specifies the program invoked by ^_ in the Composer,\n# or the \"enable-alternate-editor-implicitly\" feature.";
 
 CONF_TXT_T cf_text_speller[] =		"Specifies the program invoked by ^T in the Composer.";
@@ -503,6 +515,18 @@
 				cf_text_thread_lastreply_char},
 {"character-set",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
 				cf_text_character_set},
+#ifdef HAVE_ICONV
+{"send-charset",	 		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+				cf_text_send_charset},
+#endif
+{"assumed-charset",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+				cf_text_assumed_charset},
+{"charset-aliases",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+				cf_text_charset_aliases},
+#ifdef HAVE_ICONV
+{"iconv-aliases",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+				cf_text_iconv_aliases},
+#endif
 {"editor",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
 				cf_text_editor},
 {"speller",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
@@ -2014,6 +2038,14 @@
     set_current_val(&vars[V_SIGNATURE_FILE], TRUE, TRUE);
     set_current_val(&vars[V_LITERAL_SIG], TRUE, TRUE);
     set_current_val(&vars[V_CHAR_SET], TRUE, TRUE);
+#ifdef HAVE_ICONV
+    set_current_val(&vars[V_SEND_CHAR_SET], TRUE, TRUE);
+#endif
+    set_current_val(&vars[V_ASSUMED_CHAR_SET], TRUE, TRUE);
+    set_current_val(&vars[V_CHAR_SET_ALIASES], TRUE, TRUE);
+#ifdef HAVE_ICONV
+    set_current_val(&vars[V_ICONV_ALIASES], TRUE, TRUE);
+#endif
     set_current_val(&vars[V_GLOB_ADDRBOOK], TRUE, TRUE);
     set_current_val(&vars[V_ADDRESSBOOK], TRUE, TRUE);
     set_current_val(&vars[V_FORCED_ABOOK_ENTRY], TRUE, TRUE);
--- pine4.56/pine/mailindx.c
+++ iconv-7d-2/pine/mailindx.c
@@ -5863,7 +5863,9 @@
 	if(l = prefix ? strlen(prefix) : 0)
 	  strcpy(s, prefix);
 
-	sprintf(buftmp, "%.75s", addr->personal);
+        /* sprintf(buftmp, "%.75s", addr->personal); */
+	strncpy(buftmp,  addr->personal,75);
+	buftmp[75]='\0';
 	p = (char *) rfc1522_decode((unsigned char *) tmp_20k_buf,
 				    SIZEOF_20KBUF, buftmp, &dummy);
 	removing_leading_and_trailing_white_space(p);
--- pine4.56/pine/mailpart.c
+++ iconv-7d-2/pine/mailpart.c
@@ -4010,7 +4010,8 @@
 		    fs_give((void **) &p);
 		}
 		else
-		  passed = !strucmp(test + 9, "us-ascii");
+		  passed = !strucmp(test + 9, 
+		    ps_global->VAR_ASSUMED_CHAR_SET ? ps_global->VAR_ASSUMED_CHAR_SET : "us-ascii");
 	    }
 	    else
 	      dprint(1, (debugfile,
--- pine4.56/pine/mailview.c
+++ iconv-7d-2/pine/mailview.c
@@ -346,6 +346,8 @@
 int	    url_bogus PROTO((char *, char *));
 long        doubleclick_handle PROTO((SCROLL_S *, HANDLE_S *, 
 				      int *, int *));
+int         get_charset_filters PROTO((FILTLIST_S *, BODY *, CONV_TABLE **));
+
 #ifdef	_WINDOWS
 int	    format_message_popup PROTO((SCROLL_S *, int));
 int	    simple_text_popup PROTO((SCROLL_S *, int));
@@ -1507,6 +1509,7 @@
 #endif
 
         if(text2 = (void *)mail_fetchtext(ps_global->mail_stream, msgno)){
+	    FILTLIST_S	filters[8], *filtpnt;
  	    if(!gf_puts(NEWLINE, pc))		/* write delimiter */
 	      goto write_error;
 #if	defined(DOS) && !defined(WIN32)
@@ -1515,11 +1518,13 @@
 	    gf_set_readc(&gc, text2, (unsigned long)strlen(text2), CharStar);
 #endif
 	    gf_filter_init();
-	    /* link in filters, similar to what is done in decode_text() */
-	    if(!ps_global->pass_ctrl_chars){
-		gf_link_filter(gf_escape_filter, NULL);
-		gf_link_filter(gf_control_filter, NULL);
-	    }
+
+	    /* get the charset filters and link them in */
+	    get_charset_filters(filters, body, NULL);
+	    for(filtpnt = filters ; filtpnt->filter; filtpnt++)
+		gf_link_filter(filtpnt->filter, filtpnt->data);
+
+	    /* link in more filters, similar to what is done in decode_text() */
 	    gf_link_filter(gf_tag_filter, NULL);
 
 	    if((F_ON(F_VIEW_SEL_URL, ps_global)
@@ -1872,6 +1877,9 @@
     char     *t;
     size_t    n, len;
     unsigned char *p, *tmp = NULL;
+#ifdef HAVE_ICONV
+    char *assumed_charset = NULL;
+#endif
  
     /*
      * Warning. Some callers of this routine use the first half
@@ -1888,7 +1896,26 @@
 	p = (unsigned char *)(tmp_20k_buf+10000);
     }
 
+
+#ifdef HAVE_ICONV
+    /*
+     * reset VAR_ASSUMED_CHAR_SET to '' temporarily to avoid 
+     * a 'conflict' between the charset conversion with iconv(3)
+     * and the list management editorial
+     */
+    if (ps_global->VAR_ASSUMED_CHAR_SET && *(ps_global->VAR_ASSUMED_CHAR_SET)){
+	assumed_charset = (char *) fs_get(strlen(ps_global->VAR_ASSUMED_CHAR_SET) + 1);
+	strcpy(assumed_charset, ps_global->VAR_ASSUMED_CHAR_SET);
+	(ps_global->VAR_ASSUMED_CHAR_SET)[0] = '\0'; 
+    }
+#endif
     t = (char *)rfc1522_decode(p, len, s, NULL);
+#ifdef HAVE_ICONV
+    if (assumed_charset){
+	strcpy(ps_global->VAR_ASSUMED_CHAR_SET, assumed_charset);
+	fs_give((void **)&assumed_charset);
+    }
+#endif
 
     gf_set_readc(&gc, t, strlen(t), CharStar);
 
@@ -4996,6 +5023,45 @@
     return(0);
 }
 
+get_charset_filters(filters, body, conv_table)
+    FILTLIST_S	*filters;
+    BODY        *body;
+    CONV_TABLE **conv_table;
+{
+    int		 filtcnt = 0;
+    static int   passctl;
+    char	*charset;
+
+#ifndef HAVE_ICONV
+    if(F_OFF(F_DISABLE_2022_JP_CONVERSIONS, ps_global))
+      filters[filtcnt++].filter = gf_2022_jp_to_euc;
+#endif
+    if(body && body->parameter && F_OFF(F_DISABLE_CHARSET_CONVERSIONS, ps_global)){
+	if((charset = rfc2231_get_param(body->parameter,"charset",NULL,NULL))){
+	    CONV_TABLE *ct =  conversion_table(charset, ps_global->VAR_CHAR_SET);
+	    dprint(2, (debugfile, "found charset: %s\n", charset));
+	    if(ct && ct->table){
+		dprint(2, (debugfile, "Inserting filter for charset %s.\n", charset));
+		filters[filtcnt].filter = gf_convert_charset;
+		filters[filtcnt++].data = gf_convert_charset_opt(ct->table);
+	    }
+	    if (conv_table) /* conversion table pointer requested? */
+		*conv_table = ct;
+	    fs_give((void **) &charset);
+	}
+    }
+
+    if(!ps_global->pass_ctrl_chars){
+	filters[filtcnt++].filter = gf_escape_filter;
+	filters[filtcnt].filter   = gf_control_filter;
+	/* UTF-8 needs to send bytes between 0x80 and 0x9f to the utf-8 terminal */
+	passctl = (ps_global->VAR_CHAR_SET && 
+				   !strucmp(ps_global->VAR_CHAR_SET, "utf-8"));
+	filters[filtcnt++].data = (void *) &passctl;
+    }
+    filters[filtcnt].filter = NULL;
+    return filtcnt;
+}
 
 
 /*----------------------------------------------------------------------
@@ -5029,27 +5095,8 @@
     column = (flags & FM_DISPLAY) ? ps_global->ttyo->screen_cols : 80;
     wrapit = column;
 
-    memset(filters, 0, sizeof(filters));
-    if(F_OFF(F_DISABLE_2022_JP_CONVERSIONS, ps_global))
-      filters[filtcnt++].filter = gf_2022_jp_to_euc;
-
-    if(charset = rfc2231_get_param(att->body->parameter,"charset",NULL,NULL)){
-	if(F_OFF(F_DISABLE_CHARSET_CONVERSIONS, ps_global)){
-
-	    ct = conversion_table(charset, ps_global->VAR_CHAR_SET);
-	    if(ct && ct->table){
-		filters[filtcnt].filter = gf_convert_charset;
-		filters[filtcnt++].data = gf_convert_charset_opt(ct->table);
-	    }
-	}
-
-	fs_give((void **) &charset);
-    }
-
-    if(!ps_global->pass_ctrl_chars){
-	filters[filtcnt++].filter = gf_escape_filter;
-	filters[filtcnt++].filter = gf_control_filter;
-    }
+    /* get the charset filters */
+    filtcnt = get_charset_filters(filters, att->body, &ct);
 
     if(flags & FM_DISPLAY)
       filters[filtcnt++].filter = gf_tag_filter;
@@ -5165,6 +5212,7 @@
 	if(!rv)
 	  goto write_error;
     }
+    filters[filtcnt].filter = NULL; /* Terminate filter array */
 
     err = detach(ps_global->mail_stream, msgno, att->number,
 		 NULL, pc, filtcnt ? filters : NULL);
--- pine4.56/pine/osdep/os-lnx.h
+++ iconv-7d-2/pine/osdep/os-lnx.h
@@ -214,6 +214,9 @@
  ----*/
 #define DF_DEFAULT_PRINTER        ANSI_PRINTER
 
+/*----- Virtually all Linux distributions come with glibc 2.x. with an excellent
+ * iconv implemenation */
+#define HAVE_ICONV
 
 
 /*----- The usual sendmail configuration for sending mail on Unix ------*/
--- pine4.56/pine/osdep/termout.unx
+++ iconv-7d-2/pine/osdep/termout.unx
@@ -746,7 +746,9 @@
 	   && _col + 1 == ps_global->ttyo->screen_cols))
       return;
 
-    if(!iscntrl(ch & 0x7f)){
+    if(!iscntrl(
+	!ps_global->VAR_CHAR_SET || strucmp(ps_global->VAR_CHAR_SET, "utf-8")
+         ? ch & 0x7f : ch)){
 	putchar(ch);
 	if(esc_len > 0)
 	  esc_len--;
--- pine4.56/pine/other.c
+++ iconv-7d-2/pine/other.c
@@ -7231,6 +7231,10 @@
 	return(h_config_fld_sort_rule);
       case V_CHAR_SET :
 	return(h_config_char_set);
+#ifdef HAVE_ICONV
+      case V_SEND_CHAR_SET :
+	return(h_config_send_char_set);
+#endif
       case V_EDITOR :
 	return(h_config_editor);
       case V_SPELLER :
--- pine4.56/pine/pine.h
+++ iconv-7d-2/pine/pine.h
@@ -68,6 +68,7 @@
 #define	PHONE_HOME_HOST		"docserver.cac.washington.edu"
 
 #define UNKNOWN_CHARSET		"X-UNKNOWN"
+#define US_ASCII_CHARSET	"US-ASCII"
 
 #define OUR_HDRS_LIST		"X-Our-Headers"
 
@@ -583,6 +584,14 @@
 		, V_THREAD_EXP_CHAR
 		, V_THREAD_LASTREPLY_CHAR
 		, V_CHAR_SET
+#ifdef HAVE_ICONV
+		, V_SEND_CHAR_SET
+#endif
+		, V_ASSUMED_CHAR_SET
+		, V_CHAR_SET_ALIASES
+#ifdef HAVE_ICONV
+		, V_ICONV_ALIASES
+#endif
 		, V_EDITOR
 		, V_SPELLER
 		, V_FILLCOL
@@ -813,6 +822,15 @@
 #define GLO_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].global_val.p
 #define VAR_CHAR_SET		     vars[V_CHAR_SET].current_val.p
 #define GLO_CHAR_SET		     vars[V_CHAR_SET].global_val.p
+#ifdef HAVE_ICONV
+#define VAR_SEND_CHAR_SET	     vars[V_SEND_CHAR_SET].current_val.p
+#define GLO_SEND_CHAR_SET	     vars[V_SEND_CHAR_SET].global_val.p
+#endif
+#define VAR_ASSUMED_CHAR_SET	     vars[V_ASSUMED_CHAR_SET].current_val.p
+#define VAR_CHAR_SET_ALIASES	     vars[V_CHAR_SET_ALIASES].current_val.l
+#ifdef HAVE_ICONV
+#define VAR_ICONV_ALIASES 	     vars[V_ICONV_ALIASES].current_val.l
+#endif
 #define VAR_EDITOR		     vars[V_EDITOR].current_val.l
 #define GLO_EDITOR		     vars[V_EDITOR].global_val.l
 #define VAR_SPELLER		     vars[V_SPELLER].current_val.p
@@ -2068,11 +2086,18 @@
     ColAdj	 adjustment;
 } INDEX_COL_S;
 
+#ifdef HAVE_ICONV
+#include <iconv.h>
+typedef iconv_t         conversion_t;
+#else
+typedef unsigned char * conversion_t;
+#endif
+
 typedef struct conversion_table {
     char          *from_charset;
     char          *to_charset;
     int            quality;
-    unsigned char *table;
+    conversion_t   table;
 } CONV_TABLE;
 
 
@@ -3900,7 +3925,7 @@
 void	    gf_2022_jp_to_euc PROTO((FILTER_S *, int));
 void	    gf_euc_to_2022_jp PROTO((FILTER_S *, int));
 void	    gf_convert_charset PROTO((FILTER_S *, int));
-void	   *gf_convert_charset_opt PROTO((unsigned char *));
+void	   *gf_convert_charset_opt PROTO((conversion_t));
 void	    gf_escape_filter PROTO((FILTER_S *, int));
 void	    gf_control_filter PROTO((FILTER_S *, int));
 void	    gf_tag_filter PROTO((FILTER_S *, int));
@@ -4696,6 +4721,12 @@
 unsigned char *trans_euc_to_2022_jp PROTO((unsigned char *));
 unsigned char *trans_2022_jp_to_euc PROTO((unsigned char *));
 
+#ifdef HAVE_ICONV
+iconv_t        get_iconv_d PROTO((char *, char *));
+unsigned char* resolve_charset_alias PROTO((char *, char **));
+unsigned char *trans_with_iconv PROTO((unsigned char *, char *, char *));
+#endif
+
 
 /*-- takeaddr.c --*/
 char	  **detach_vcard_att PROTO ((MAILSTREAM *, long, BODY *, char *));
--- pine4.56/pine/pine.hlp
+++ iconv-7d-2/pine/pine.hlp
@@ -17669,6 +17669,29 @@
 &lt;End of help on this topic&gt;
 </BODY>
 </HTML>
+====== h_config_send_char_set =====
+<HTML>
+<HEAD>
+<TITLE>OPTION: Send-Charset</TITLE>
+</HEAD>
+<BODY>
+<H1>OPTION: Send-Charset</H1>
+
+If it's set, the headers and the body of an outgoing message is converted
+from the value of character-set (display/terminal charset) to the value
+of this option. You have to set this option if your terminal/display charset
+(say, UTF-8) is different from the charset you want your outgoing messsages
+to be in (say, ISO-8859-1, EUC-KR, Big5, GB2312) because your correspondents
+can't handle emails in UTF-8.
+
+<P>
+<UL>
+<LI><A HREF="h_finding_help">Finding more information and requesting
+help</A>
+</UL><P>
+&lt;End of help on this topic&gt;
+</BODY>
+</HTML>
 ====== h_config_editor =====
 <HTML>
 <HEAD>
--- pine4.56/pine/reply.c
+++ iconv-7d-2/pine/reply.c
@@ -1514,18 +1514,32 @@
        && (decoded[0] == 'R' || decoded[0] == 'r')
        && (decoded[1] == 'E' || decoded[1] == 'e')){
 
-        if(decoded[2] == ':')
-	  sprintf(buf, "%.200s", subject);
+	if(decoded[2] == ':'){
+	    strncpy(buf, subject,l);  
+	    buf[l]='\0';
+	}
 	else if((decoded[2] == '[') && (p = strchr(decoded, ']'))){
 	    p++;
 	    while(*p && isspace((unsigned char)*p)) p++;
-	    if(p[0] == ':')
-	      sprintf(buf, "%.200s", subject);
+	    if(p[0] == ':'){
+		strncpy(buf, subject,l);  
+		buf[l]='\0';
+	    }   
 	}
     }
-    if(!buf[0])
-      sprintf(buf, "Re: %.200s", (subject && *subject) ? subject : "your mail");
-
+    if(!buf[0]) {
+	/*
+	 * Used to be 
+	 * sprintf(buf, "Re: %.200s", (subject && *subject) ? subject : 
+	 * 	"your mail"); 		 
+	 * Some implementations of sprintf() are locale-dependent and
+	 * don't pass through an invalid sequence of bytes blindly. 
+	 * Use strncpy() instead:
+	 */
+	strcpy(buf,"Re: ");
+	strncpy(buf+4, (subject && *subject) ? subject : "your mail",l);  
+	buf[l+4]='\0';
+    }
     fs_give((void **) &tmp);
     return(buf);
 }
@@ -4479,6 +4493,7 @@
     ENVELOPE *outgoing;
     BODY     *body = NULL;
     MESSAGECACHE *mc;
+    char     *temp_send_cset = NULL;
 
     outgoing		 = mail_newenvelope();
     outgoing->message_id = generate_message_id();
@@ -4561,6 +4576,18 @@
 
     gf_clear_so_writec((STORE_S *) msgtext);
 
+#ifdef HAVE_ICONV
+    /*
+     * reset VAR_SEND_CHAR_SET to '' temporarily NOT to 
+     * apply  the charset conversion to a bounced message.
+     */
+    if (ps_global->VAR_SEND_CHAR_SET && *(ps_global->VAR_SEND_CHAR_SET)){
+	temp_send_cset = (char *) fs_get(strlen(ps_global->VAR_SEND_CHAR_SET) + 1);
+	strcpy(temp_send_cset, ps_global->VAR_SEND_CHAR_SET);
+	(ps_global->VAR_SEND_CHAR_SET)[0] = '\0'; 
+    }
+#endif
+
     if(pine_simple_send(outgoing, &body, pmt_who, pmt_cnf, to,
 			!(to && *to) ? SS_PROMPTFORTO : 0) < 0){
 	errstr = "";		/* p_s_s() better have explained! */
@@ -4569,6 +4596,13 @@
 	  mail_flag(stream, long2string(rawno), "\\SEEN", 0);
     }
 
+#ifdef HAVE_ICONV
+    if (temp_send_cset){
+	strcpy(ps_global->VAR_SEND_CHAR_SET, temp_send_cset);
+	fs_give((void **)&temp_send_cset);
+    }
+#endif
+
     /* Just for good measure... */
     mail_free_envelope(&outgoing);
     pine_free_body(&body);
@@ -4729,8 +4763,10 @@
 
     i = 0;			/* for start of filter list */
 
+#ifndef HAVE_ICONV
     if(F_OFF(F_DISABLE_2022_JP_CONVERSIONS, ps_global))
       filters[i++].filter = gf_2022_jp_to_euc;
+#endif
 
     if(charset = rfc2231_get_param(body->parameter,"charset",NULL,NULL)){
 	if(F_OFF(F_DISABLE_CHARSET_CONVERSIONS, ps_global)){
--- pine4.56/pine/send.c
+++ iconv-7d-2/pine/send.c
@@ -94,6 +94,9 @@
 int	   filter_message_text PROTO((char *, ENVELOPE *, BODY *, STORE_S **,
 				      METAENV *));
 void	   filter_msgtxt_euc_to_2022_jp PROTO((BODY *));
+#ifdef HAVE_ICONV
+void	   filter_msgtxt_to_send_charset PROTO((BODY *));
+#endif
 void	   pine_send_newsgroup_name PROTO((char *, char*, size_t));
 long	   message_format_for_pico PROTO((long, int (*)(int)));
 char	  *send_exit_for_pico PROTO((struct headerentry *, void (*)()));
@@ -6242,6 +6245,55 @@
     }
 }
 
+#ifdef HAVE_ICONV
+/*
+ * Take the PicoText pointed to and replace it with PicoText which has been
+ * filtered to change the 'character-set' (display/terminal-charset) to 
+ * 'send-charset'. (based on filter_msgtxt_euc_to_2022_jp, above)
+ */
+void
+filter_msgtxt_to_send_charset(body)
+    BODY *body;
+{
+    STORE_S **so = (STORE_S **)((body->type == TYPEMULTIPART)
+				? &body->nested.part->body.contents.text.data
+				: &body->contents.text.data);
+    STORE_S  *filtered_so = NULL; 
+    gf_io_t   pc, gc;
+    char     *errstr;
+    CONV_TABLE *ct;
+    char * assumed_save = ps_global->VAR_ASSUMED_CHAR_SET;
+
+    ps_global->VAR_ASSUMED_CHAR_SET = NULL;
+    ct = conversion_table(ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET);
+    ps_global->VAR_ASSUMED_CHAR_SET = assumed_save;
+
+    if(ct->table && (filtered_so = so_get(PicoText, NULL, EDIT_ACCESS))){
+	so_seek(*so, 0L, 0);
+	gf_filter_init();
+	gf_link_filter(gf_convert_charset, gf_convert_charset_opt(ct->table)); 
+	gf_set_so_readc(&gc, *so);
+	gf_set_so_writec(&pc, filtered_so);
+	if(errstr = gf_pipe(gc, pc)){
+	    so_give(&filtered_so);
+	    dprint(1, (debugfile,
+		       "Error with converting to send-charset %s:%s\n", 
+		       ps_global->VAR_SEND_CHAR_SET, errstr));
+	    return;
+	}
+
+	gf_clear_so_readc(*so);
+	gf_clear_so_writec(filtered_so);
+
+	so_give(so);
+	*so = filtered_so;
+    }
+    dprint(5, (debugfile,
+	       "Succeeded in converting %s to %s for outgoing email\n",
+	       ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET));
+}
+#endif
+
 
 /*----------------------------------------------------------------------
     Pass the first text segment of the message thru the "send filter"
@@ -7471,7 +7523,8 @@
 		src = pf->scratch ? pf->scratch
 				  : (*pf->text) ? *pf->text : "";
 
-		len = strlen(src)+1;
+		/* multiplyer 5 should be enough for EUC-JP -> ISO-2022-JP */
+		len = strlen(src)*5+1;  
 		p = (char *)fs_get(len * sizeof(char));
 		if(rfc1522_decode((unsigned char *)p, len, src, &charset)
 						   == (unsigned char *) p){
@@ -7602,10 +7655,18 @@
 		    fs_give((void **)pf->text);
 
 		  if(*pf->scratch){
+#ifndef HAVE_ICONV
 		      if(ps_global->VAR_CHAR_SET &&
 		         !strucmp(ps_global->VAR_CHAR_SET, "iso-2022-jp"))
 		        *pf->text =
 			 (char *) trans_euc_to_2022_jp((unsigned char *) (pf->scratch));
+#else
+		      if(ps_global->VAR_CHAR_SET && ps_global->VAR_SEND_CHAR_SET &&
+		         !strucmp(ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET))
+		        *pf->text =
+			 (char *) trans_with_iconv((unsigned char *) (pf->scratch),
+			   ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET);  
+#endif
 		      else
 		        *pf->text = cpystr(pf->scratch);
 		  }
@@ -7617,6 +7678,7 @@
 	  fs_give((void **)&pf->scratch);	/* free now useless text */
       }
 
+#ifndef HAVE_ICONV
     /*
      * Change EUC (unix Pine) or Shift-JIS (PC-Pine) into ISO-2022-JP
      * in the message body.
@@ -7632,6 +7694,16 @@
        && F_OFF(F_DISABLE_2022_JP_CONVERSIONS, ps_global))
 	filter_msgtxt_euc_to_2022_jp(*bod);
 
+#else
+    /*
+     * Convert the message body in display charset('characer set') to
+     * 'send-charset'
+     */
+    if(bod && *bod && ps_global->VAR_CHAR_SET && ps_global->VAR_SEND_CHAR_SET
+       && strucmp(ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET))
+	filter_msgtxt_to_send_charset(*bod);
+#endif
+
     create_message_body(bod, attach, charset);
     pine_encode_body(*bod);
 
@@ -7667,15 +7739,25 @@
 	      p = (char *) rfc1522_decode((unsigned char *)tmp_20k_buf,
 					  SIZEOF_20KBUF, buftmp, &charset);
 
+#ifndef HAVE_ICONV
 	      q = (char *) trans_euc_to_2022_jp((unsigned char *)(a->personal));
+#else
+	      q = (char *) trans_with_iconv((unsigned char *)(a->personal),
+		      ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET);
+#endif
 
 	      if(p == tmp_20k_buf		/* personal was decoded */
 		 && !strcmp(q, p)){		/* still matches what it was */
 		  fs_give((void **)&a->personal);
 		  a->personal = cpystr(old->personal);
 	      }
+#ifndef HAVE_ICONV
 	      else if(ps_global->VAR_CHAR_SET &&
 		     !strucmp(ps_global->VAR_CHAR_SET, "iso-2022-jp")){
+#else
+	      else if(ps_global->VAR_CHAR_SET && ps_global->VAR_SEND_CHAR_SET
+		      && strucmp(ps_global->VAR_CHAR_SET, ps_global->VAR_SEND_CHAR_SET)){
+#endif
 		  /*
 		   * Convert EUC (unix Pine) or Shift-JIS (PC-Pine) into
 		   * ISO-2022-JP.
@@ -7765,9 +7847,15 @@
 			   rfc1522_encode(tmp_20k_buf,
 					  SIZEOF_20KBUF,
 					  (unsigned char *) pa->description,
+#ifndef HAVE_ICONV
 					  ps_global->VAR_CHAR_SET));
-	      }
+#else
+					   ps_global->VAR_SEND_CHAR_SET ? 
+					   ps_global->VAR_SEND_CHAR_SET :
+					   ps_global->VAR_CHAR_SET));
+#endif
 
+	      }
 	      break;
 	  }
 
@@ -7825,7 +7913,13 @@
         p->body.description = cpystr(rfc1522_encode(tmp_20k_buf,
 					   SIZEOF_20KBUF,
 				           (unsigned char *) pa->description,
+#ifndef HAVE_ICONV
+					   ps_global->VAR_CHAR_SET));
+#else
+					   ps_global->VAR_SEND_CHAR_SET ? 
+					   ps_global->VAR_SEND_CHAR_SET :
 					   ps_global->VAR_CHAR_SET));
+#endif
 
 	/* Add name attribute for backward compatibility */
 	for(parmp = &p->body.parameter; *parmp; )
@@ -8207,6 +8301,22 @@
 	    if(new_encoding != ENCBINARY)
 	      new_encoding = ENC8BIT;  /* short lines, < 30% 8 bit chars */
 	}
+	else if(max_line < 300L || (eight_bit_chars * 100L)/len < 80L){
+	    /*
+	     * The previous test misses East Asian, Greek and Russian text
+	     * in ISO-8859-7, KOI8-R, EUC-KR, Big5, and GB2312
+	     * with a lot higher percentage of 8bit chars than Western European text
+	     * in ISO-8859-x. For them, use a relaxed condition for the 
+	     * percentage of 8bit chars along with a more strict condition
+	     * on the maximum line length. 
+	     */
+	    can_be_ascii--;
+	    if(body->type == TYPEOTHER)
+	      body->type = TYPETEXT;
+
+	    if(new_encoding != ENCBINARY)
+	      new_encoding = ENC8BIT;  /* short lines, < 30% 8 bit chars */
+	}
 	else{
 	    can_be_ascii--;
 	    if(body->type == TYPEOTHER){
@@ -8263,7 +8373,13 @@
 
 	set_mime_charset(pm,
 			 can_be_ascii > 0,
+#ifndef HAVE_ICONV
 			 charset ? charset : ps_global->VAR_CHAR_SET);
+#else
+			 charset ? charset : ps_global->VAR_SEND_CHAR_SET ?
+			 ps_global->VAR_SEND_CHAR_SET : 
+			 ps_global->VAR_CHAR_SET);
+#endif
     }
 
     if(body->encoding == ENCOTHER)
@@ -8386,9 +8502,19 @@
     char *value, *folded = NULL;
 
 
+#ifdef HAVE_ICONV
+    text = (char *) trans_with_iconv(text, ps_global->VAR_CHAR_SET,
+			    ps_global->VAR_SEND_CHAR_SET);
+#endif
     value = encode_header_value(tmp_20k_buf, SIZEOF_20KBUF,
 				(unsigned char *) text,
+#ifndef HAVE_ICONV
+			        ps_global->VAR_CHAR_SET,
+#else
+			        ps_global->VAR_SEND_CHAR_SET ?
+			        ps_global->VAR_SEND_CHAR_SET :
 			        ps_global->VAR_CHAR_SET,
+#endif
 				encode_whole_header(field, header));
     
     if(value && value == text){	/* no encoding was done, have to fold */
@@ -8452,6 +8578,11 @@
 	  fs_give((void **)&folded);
     }
     
+#ifdef HAVE_ICONV
+    if (text)
+	fs_give((void **)&text);
+#endif
+    
     return(ret);
 }
 
--- pine4.56/pine/strings.c
+++ iconv-7d-2/pine/strings.c
@@ -80,6 +80,10 @@
 
  ====*/
 
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
+
 #include "headers.h"
 #include "../c-client/utf8.h"
 
@@ -664,6 +668,151 @@
 }
 
 
+/*
+ *  * * * * * *  Character set translation helpers  * * * * * * * *
+ */
+
+/*
+ * Like sstrncpy, but with charset conversion(if possible) and null termination.
+ * *dest is left pointing a the terminating zero byte. It will not write
+ * more than length bytes. To copy the whole string, the output buffer and
+ * the length passed must be strlen(source)+1 in order to get a full copy.
+ *
+ * fromcset -- charset to convert from
+ * tocset   -- charset ro convert to
+ * **dest   -- address of a pointer which points to the destination buffer
+ * *src     -- address of the start of the rfc2047-decoded source buffer
+ * len      -- maximum number of bytes to write at **dest and increase *dest
+ *             __including__ the terminating null. 
+ */ 
+void
+conv_sstrncpy(fromcset, tocset, dest, src, length)
+    char  *fromcset;
+    char  *tocset;
+    char **dest;
+    char  *src;
+    size_t length;
+{
+#ifdef HAVE_ICONV
+    static char *charset   = 0;
+    static char *s_fromcset= 0;
+    static char *s_tocset  = 0;
+    static iconv_t iconv_d = 0;
+
+    if ((!fromcset || !*fromcset) && (!tocset || !*tocset))
+	goto noconv;
+
+    fromcset = (fromcset && *fromcset) ? fromcset : ps_global->VAR_CHAR_SET;
+    tocset   = (tocset   && *tocset)   ? tocset   : ps_global->VAR_CHAR_SET;
+
+    if (s_fromcset && strucmp(s_fromcset, fromcset))
+	fs_give((void **)&s_fromcset);
+
+    if (s_tocset   && strucmp(s_tocset,   tocset))
+	fs_give((void **)&s_tocset);
+    
+    if (!s_fromcset || !s_tocset) {
+	if (iconv_d) {
+	    iconv_close(iconv_d);
+	    iconv_d = 0;
+	}
+	fromcset = resolve_charset_alias(fromcset,
+					 ps_global->VAR_CHAR_SET_ALIASES);
+	tocset   = resolve_charset_alias(tocset,
+					 ps_global->VAR_CHAR_SET_ALIASES);
+	s_fromcset = cpystr(fromcset);
+	s_tocset   = cpystr(tocset);
+	iconv_d    = get_iconv_d(tocset, fromcset);
+	dprint(2, (debugfile,"new charsets %s -> %s, get new iconv_d:%p\n", 
+		    fromcset, tocset, iconv_d));
+    }
+    else {
+	dprint(2, (debugfile, "reusing old charsets: %s -> %s\n",
+			      s_fromcset, s_tocset));
+	if (iconv_d)
+	    iconv(iconv_d, NULL, NULL, NULL, NULL);
+    }
+    if (iconv_d) {
+	size_t inbytesleft = strlen(src);
+	char *buf=*dest;
+	length--;      /* reserve a byte for '\0' */
+	dprint(7, (debugfile, "inlen=%d length=%3d: >%s<\n",
+			inbytesleft, length, src));
+	int irrev = iconv(iconv_d, &src, &inbytesleft, dest, &length);
+	**dest = '\0'; /* terminate the output string */
+	dprint(7, (debugfile, "iconv ret/irrev=%3d: >%s<\n", irrev, buf));
+	return;
+    }
+noconv:
+#endif
+    dprint(7, (debugfile,"no convert: >%s<(%d)\n", src, length));
+    sstrncpy(dest, src, length);
+    **dest = '\0'; /* ensure that the output string is terminated */
+}
+
+unsigned char*
+resolve_charset_alias(cs, aliases)
+    char  *cs;
+    char **aliases;
+{
+    int i;
+    char *bdry;
+
+    if ( !aliases )
+	return cs;
+    for (i=0; aliases[i] && *(aliases[i]); i++) {
+	if (bdry=strchr(aliases[i],':')) {
+	    *bdry='\0';
+	    if (!strucmp(aliases[i], cs)) {
+	  	*bdry=':';
+	  	return *(bdry+1) ? bdry+1 : cs;
+	    }
+	    *bdry=':';
+	}
+    }
+    return cs;
+}
+#ifdef HAVE_ICONV
+iconv_t get_iconv_d(toset, fromset)
+  char *toset;
+  char *fromset;
+{
+  char *fromcode, *tocode;
+  iconv_t iconv_d;
+
+  fromset = resolve_charset_alias(fromset,ps_global->VAR_ICONV_ALIASES);
+  toset   = resolve_charset_alias(toset,ps_global->VAR_ICONV_ALIASES);
+
+  if (!fromset ||
+      !strucmp(fromset, US_ASCII_CHARSET) ||
+      (toset && !strucmp(fromset, toset)))
+       return NULL; 
+
+  /* 8 = strlen("US-ASCII"), 11 = strlen ("//TRANSLIT")+1; */
+
+  tocode   = (char *) fs_get((size_t)((toset   ? strlen(toset)   : 8) + 11 )); 
+  fromcode = (char *) fs_get((size_t)((fromset ? strlen(fromset) : 8) + 1  ));
+
+  strcpy(tocode, toset ? toset : US_ASCII_CHARSET); 
+  if (strucmp(tocode, "UTF-8"))   // No need of transliteration for UTF-8
+      strcat(tocode, "//TRANSLIT");
+
+  strcpy(fromcode, fromset ? fromset : US_ASCII_CHARSET); 
+
+  if ( (iconv_d = iconv_open(tocode, fromcode)) != (iconv_t) -1 ) {
+       dprint(2, (debugfile,"iconv open successful: from %s to %s\n",fromcode,tocode));
+  } 	
+  else {
+       dprint(2, (debugfile,"iconv open failed: from %s to %s\n",fromcode,tocode));
+       iconv_d = NULL;
+  }    
+  fs_give((void **) &tocode);
+  fs_give((void **) &fromcode);
+
+  return iconv_d;
+}
+#endif
+
 /*----------------------------------------------------------------------
   copy at most n chars of the source string onto the destination string
   returning pointer to start of destination and converting any undisplayable
@@ -925,6 +1074,35 @@
     return(rv);
 }
 
+#ifdef HAVE_ICONV
+/*
+ * Converts the source string in fromcset to tocset and copy the result
+ * into allocated space.
+ * Caller is responsible for freeing the result.
+ */
+unsigned char *
+trans_with_iconv(src, fromcset, tocset)
+    unsigned char *src;
+    char *fromcset;
+    char *tocset;
+{
+    size_t len;
+    unsigned char *rv, *pstr;
+    if (!src)
+	return NULL;
+
+    dprint(5, (debugfile, "translating from %s to %s\n",fromcset, tocset));
+
+    /* 
+     * XXX: multiplier of 5 should be sufficient for virtually all
+     * cases (EUC-JP -> ISO-2022-JP)
+     */
+    len = strlen((char *) src) * 5 + 1;
+    pstr = rv = (unsigned char *) fs_get(sizeof(char) * len);
+    conv_sstrncpy(fromcset, tocset, (char **) &pstr, src, len);
+    return rv;
+}
+#endif
 
 char *xdays[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", NULL};
 
@@ -2912,7 +3090,7 @@
 				    char **));
 int	       rfc1522_valtok PROTO((int));
 int	       rfc1522_valenc PROTO((int));
-int	       rfc1522_valid PROTO((char *, char **, char **, char **,
+int	       rfc1522_valid PROTO((char *, int, char **, char **, char **,
 				    char **));
 char	      *rfc1522_8bit PROTO((void *, int));
 char	      *rfc1522_binary PROTO((void *, int));
@@ -2942,6 +3120,7 @@
     unsigned long  l;
     int		   i;
     int            translate_2022_jp = 0;
+    unsigned char *cset_r;    /* cset with alias resolution */
 
     *d = '\0';					/* init destination */
     if(charset)
@@ -2949,7 +3128,7 @@
 
     while(s && (sw = strstr(s, RFC1522_INIT))){
 	/* validate the rest of the encoded-word */
-	if(rfc1522_valid(sw, &cset, &enc, &txt, &ew)){
+	if(rfc1522_valid(sw, 1, &cset, &enc, &txt, &ew)){
 	    if(!rv)
 	      rv = d;				/* remember start of dest */
 
@@ -2967,6 +3146,9 @@
 	    if(lang = strchr(cset, '*'))
 	      *lang++ = '\0';
 
+	    cset_r = resolve_charset_alias(cset,ps_global->VAR_CHAR_SET_ALIASES);
+
+#ifndef HAVE_ICONV
 	    /* Insert text explaining charset if we don't know what it is */
 	    if(F_OFF(F_DISABLE_2022_JP_CONVERSIONS, ps_global)
 	       && !strucmp((char *) cset, "iso-2022-jp")){
@@ -2991,19 +3173,24 @@
 		    }
 		}
 		/* else, just translate it silently */
-	    }
-	    else if((!ps_global->VAR_CHAR_SET
-		     || strucmp((char *) cset, ps_global->VAR_CHAR_SET))
-	            && strucmp((char *) cset, "US-ASCII")){
+	    } else
+#endif
+	    if((!ps_global->VAR_CHAR_SET
+		     || strucmp((char *) cset_r, ps_global->VAR_CHAR_SET))
+		    && strucmp((char *) cset_r, US_ASCII_CHARSET)){
+
 		dprint(5, (debugfile, "RFC1522_decode: charset mismatch: %s\n",
 			   cset));
+#ifndef HAVE_ICONV /* With iconv, we convert during copy, no cset copy */
 		if(!cs)
 		  cs = cpystr(cset);
+#endif
 
 		if(charset){
 		    if(!*charset)		/* only write first charset */
 		      *charset = cpystr(cset);
 		}
+#ifndef HAVE_ICONV /* We don't tag beforehand, if needed, we can during copy! */
 		else{
 		    if(d-rv<len-1)
 		      *d++ = '[';
@@ -3014,6 +3201,7 @@
 		    if(d-rv<len-1)
 		      *d++ = SPACE;
 		}
+#endif
 	    }
 
 	    /* based on encoding, write the encoded text to output buffer */
@@ -3039,12 +3227,9 @@
 		  q = NULL;
 
 		if(p = rfc822_qprint((unsigned char *)txt, strlen(txt), &l)){
-		    strncpy((char *) d, (char *) p, len-1-(d-rv));
-		    d[len-1-(d-rv)] = '\0';
+	    	    dprint(7, (debugfile, "rfc822_q:"));
+		    conv_sstrncpy(cset_r, NULL, &d, p, len-(d-rv));
 		    fs_give((void **)&p);	/* free encoded buf */
-		    d += l;			/* advance dest ptr to EOL */
-		    if(d-rv > len-1)
-		      d = rv+len-1;
 		}
 		else{
 		    if(q)
@@ -3065,12 +3250,9 @@
 	      case 'B' :			/* 'B' encoding */
 	      case 'b' :
 		if(p = rfc822_base64((unsigned char *) txt, strlen(txt), &l)){
-		    strncpy((char *) d, (char *) p, len-1-(d-rv));
-		    d[len-1-(d-rv)] = '\0';
+	    	    dprint(7, (debugfile, "rfc822_base64:"));
+		    conv_sstrncpy(cset_r, NULL, &d, p, len-(d-rv));
 		    fs_give((void **)&p);	/* free encoded buf */
-		    d += l;			/* advance dest ptr to EOL */
-		    if(d-rv > len-1)
-		      d = rv+len-1;
 		}
 		else
 		  goto bogus;
@@ -3095,30 +3277,31 @@
 	      lang[-1] = '*';
 	}
 	else{
-
-	    /*
-	     * Found intro, but bogus data followed, treat it as normal text.
-	     */
-
+	    /* Found intro, but bogus data followed, copy it and continue */
+#ifdef HAVE_ICONV
+	    if (!rv)
+		rv=d; /* remember start of dest */
+#endif
+	    l = min(len-(d-rv),(sw-s)+ RFC1522_INIT_L); /* data to copy */
 	    /* if already copying to destn, copy it */
-	    if(rv){
-		strncpy((char *) d, s,
-			(int) min((l = (sw - s) + RFC1522_INIT_L),
-			len-1-(d-rv)));
-		d += l;				/* advance d, tie off text */
-		if(d-rv > len-1)
-		  d = rv+len-1;
-		*d = '\0';
-		s += l;				/* advance s beyond intro */
-	    }
-	    else
-	      s += ((sw - s) + RFC1522_INIT_L);
+	    if(rv)
+		conv_sstrncpy(ps_global->VAR_ASSUMED_CHAR_SET, NULL,
+			(char **)&d, s, (int) l);
+	    s += l; /* advance s beyond intro */
 	}
     }
 
-    if(rv && *s)				/* copy remaining text */
-      strncat((char *) rv, s, len - 1 - strlen((char *) rv));
+    if (s && *s) { /* copy remaining text */
+#ifdef HAVE_ICONV
+	if (!rv)
+	    rv=d; /* remember start of dest */
+#endif
+	if (rv)
+	    conv_sstrncpy(ps_global->VAR_ASSUMED_CHAR_SET, NULL,
+		(char **)&d, s, len - strlen((char *)rv));
+    }
 
+#ifndef HAVE_ICONV /* with iconv, we are done, we have converted during copy */
     if(translate_2022_jp){
 	unsigned char *trans;
 
@@ -3157,6 +3340,9 @@
 
     if(cs)
       fs_give((void **) &cs);
+#endif
+    dprint(7, (debugfile, "from:>%s<\n", start));
+    dprint(7, (debugfile, "to  :>%s<\n", rv));
 
     return(rv ? rv : (unsigned char *) start);
 
@@ -3222,10 +3408,14 @@
 
 /*
  * rfc1522_valid - validate the given string as to it's rfc1522-ness
+ * if relaxchk is true, double the maximum length of an encoded word.
+ * this is necessary to decode overlong encoded words generated by 
+ * numerous incompliant implementations of RFC 2047 (1522).
  */
 int
-rfc1522_valid(s, charset, enc, txt, endp)
+rfc1522_valid(s, relaxchk, charset, enc, txt, endp)
     char  *s;
+    int  relaxchk;
     char **charset;
     char **enc;
     char **txt;
@@ -3234,10 +3424,15 @@
     char *c, *e, *t, *p;
     int   rv;
 
+    /* relax the length condition by doubling the max length of an
+     * encoded word. this isf
+     */
     rv = rfc1522_token(c = s+RFC1522_INIT_L, rfc1522_valtok, RFC1522_DLIM, &e)
 	   && rfc1522_token(++e, rfc1522_valtok, RFC1522_DLIM, &t)
 	   && rfc1522_token(++t, rfc1522_valenc, RFC1522_TERM, &p)
-	   && p - s <= RFC1522_MAXW;
+	   && p - s <= RFC1522_MAXW * (relaxchk ? 2 : 1);
+
+    dprint(7, (debugfile, "rfc1522_valid: r:%d, %d >%s<\n", relaxchk, rv, s));
 
     if(charset)
       *charset = c;
@@ -3288,7 +3483,7 @@
       }
       else if(*p == RFC1522_INIT[0]
 	      && !strncmp((char *) p, RFC1522_INIT, RFC1522_INIT_L)){
-	  if(rfc1522_valid((char *) p, NULL, NULL, NULL, (char **) &q))
+	  if(rfc1522_valid((char *) p, 0, NULL, NULL, NULL, (char **) &q))
 	    p = q + RFC1522_TERM_L - 1;		/* advance past encoded gunk */
       }
       else if(*p == ESCAPE && match_escapes((char *)(p+1))){
@@ -3439,7 +3634,19 @@
 
 
 /*
- * Returns a 256 character table to do the translation if feasible, else NULL.
+ * Checks if charset conversion is possible and which quality could be achived
+ *
+ * args: from_cs -- charset to convert from
+ *       to_cs   -- charset to convert to
+ *
+ * Results:
+ * CONV_TABLE->table   -- conversion table, NULL if conversion not needed
+ *                        or not supported
+ * CONV_TABLE->quality -- conversion quality(conversion not supported, not
+ *                        needed, looses special chars, or looses letters
+ *
+ * The other entries of CONV_TABLE are used inside this function only
+ * and may not be used outside unless this documentation is updated.
  */
 CONV_TABLE *
 conversion_table(from_cs, to_cs)
@@ -3453,7 +3660,27 @@
     CHARSET          *from, *to;
     static CONV_TABLE null_tab;
 
+    /*
+     * Another idea would be to check if the subject had charset tags
+     * and use this charset (we could use the last charset variable from
+     * conv_sstrcpy() in mailview.c)
+     */
+    if (ps_global->VAR_ASSUMED_CHAR_SET
+	&& (!from_cs || !*from_cs || !strucmp(UNKNOWN_CHARSET, from_cs)
+				  || !strucmp(US_ASCII_CHARSET, from_cs)))
+	    from_cs = ps_global->VAR_ASSUMED_CHAR_SET;
+
+    /*
+     * Lets do user-specified charset aliasing before starting work:
+     */
+    from_cs = resolve_charset_alias(from_cs, ps_global->VAR_CHAR_SET_ALIASES);
+    to_cs   = resolve_charset_alias(to_cs,   ps_global->VAR_CHAR_SET_ALIASES);
+
+    /*
+     * Check if we need conversion for this pair. If not, it's easy:
+     */
     if(!(from_cs && *from_cs && to_cs && *to_cs) || !strucmp(from_cs, to_cs)){
+        dprint(4, (debugfile, "no conversion from=%s to=%s\n", from_cs, to_cs));
 	memset(&null_tab, 0, sizeof(null_tab));
 	null_tab.quality = CV_NO_TRANSLATE_NEEDED;
 	return(&null_tab);
@@ -3471,6 +3698,8 @@
     /*
      * No such luck. Check to see if a translation is feasible.
      */
+    
+#ifndef HAVE_ICONV
     from = utf8_charset(from_cs);
     to   = utf8_charset(to_cs);
 
@@ -3482,15 +3711,21 @@
 	  quality = (from->script & to->script) ? CV_LOSES_SOME_LETTERS
 						     : CV_LOSES_SPECIAL_CHARS;
     }
-    
+#endif
 
     /*
      * Get rid of the cache of the previous translation table
      * and build a new one.
      */
     if(ct){
-	if(ct->table)
+	if(ct->table) {
+#ifdef HAVE_ICONV
+	  iconv_close(ct->table);
+	  ct->table = NULL;
+#else
 	  fs_give((void **) &ct->table);
+#endif
+	}
 	
 	if(ct->from_charset)
 	  fs_give((void **) &ct->from_charset);
@@ -3505,6 +3740,10 @@
 
     ct->from_charset = cpystr(from_cs);
     ct->to_charset   = cpystr(to_cs);
+#ifdef HAVE_ICONV
+    ct->table = get_iconv_d(to_cs, from_cs);
+    ct->quality = ct->table ? CV_LOSES_SPECIAL_CHARS : CV_NO_TRANSLATE_POSSIBLE;
+#else
     ct->quality = quality;
 
     if(quality == CV_NO_TRANSLATE_POSSIBLE
@@ -3549,6 +3788,7 @@
 	    }
 	}
     }
+#endif
 
 
     return(ct);
